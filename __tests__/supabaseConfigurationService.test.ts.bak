import { SupabaseConfigurationService } from '../src/config/SupabaseConfigurationService';
import { supabaseAdmin } from '../src/database/supabaseClient';
import { DetectionGroup, SystemConfig } from '../src/types/database';

// Mock Supabase client
jest.mock('../src/database/supabaseClient', () => ({
  supabaseAdmin: {
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      upsert: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      single: jest.fn(),
    }))
  }
}));

describe('SupabaseConfigurationService', () => {
  let service: SupabaseConfigurationService;
  let mockSupabaseChain: any;

  const mockGroup: DetectionGroup = {
    id: 'test-id',
    name: 'test-group',
    display_name: 'í…ŒìŠ¤íŠ¸ ê·¸ë£¹',
    characters: ['í…Œ', 'ìŠ¤', 'íŠ¸'],
    color: 0xff0000,
    emoji: 'ðŸ§ª',
    enabled: true,
    threshold: 5
  };

  const mockSettings = [
    { key_name: 'countThreshold', value_data: 5 },
    { key_name: 'alertCooldown', value_data: 300000 }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    service = new SupabaseConfigurationService();

    // Create a mock chain that can be reused
    mockSupabaseChain = {
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      upsert: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      single: jest.fn(),
    };

    // Reset the from mock to return our chain
    (supabaseAdmin.from as jest.Mock).mockReturnValue(mockSupabaseChain);
  });

  afterEach(() => {
    service.cleanup();
  });

  describe('loadConfiguration', () => {
    it('should load configuration successfully', async () => {
      // Mock groups query - note: we need to use the chain properly
      mockSupabaseChain.order.mockResolvedValueOnce({
        data: [mockGroup],
        error: null
      });

      // Mock settings query  
      mockSupabaseChain.select.mockResolvedValueOnce({
        data: mockSettings,
        error: null
      });

      const config = await service.loadConfiguration();

      expect(config).toMatchObject({
        groups: [mockGroup],
        globalSettings: {
          countThreshold: 5,
          alertCooldown: 300000,
          countResetInterval: 60000, // default value
        }
      });
      expect(config.lastModified).toBeInstanceOf(Date);
    });

    it('should return cached configuration when cache is valid', async () => {
      // First call setup
      (supabaseAdmin.from as jest.Mock)
        .mockReturnValueOnce({
          ...mockSupabaseChain,
          order: jest.fn().mockResolvedValue({ data: [mockGroup], error: null })
        })
        .mockReturnValueOnce({
          ...mockSupabaseChain,
          select: jest.fn().mockResolvedValue({ data: mockSettings, error: null })
        });

      const config1 = await service.loadConfiguration();
      const config2 = await service.loadConfiguration();

      expect(config1).toBe(config2); // Should be same instance (cached)
      expect(supabaseAdmin.from).toHaveBeenCalledTimes(2); // Only called once for each table
    });

    it('should handle database errors gracefully', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Database connection failed')
      });

      const config = await service.loadConfiguration();

      // Should return default configuration
      expect(config.groups).toHaveLength(3); // default groups
      expect(config.groups[0].name).toBe('burger');
    });

    it('should invalidate cache after TTL expires', async () => {
      // Mock Date.now to control cache expiry
      const originalDateNow = Date.now;
      let mockTime = 1000;
      Date.now = jest.fn(() => mockTime);

      try {
        mockSupabaseChain.single
          .mockResolvedValue({ data: [mockGroup], error: null })
          .mockResolvedValue({ data: mockSettings, error: null });

        // First call
        await service.loadConfiguration();

        // Advance time beyond cache TTL (30 seconds)
        mockTime += 31000;

        // Second call should hit database again
        await service.loadConfiguration();

        expect(supabaseAdmin.from).toHaveBeenCalledTimes(4); // 2 calls * 2 tables
      } finally {
        Date.now = originalDateNow;
      }
    });
  });

  describe('updateDetectionGroup', () => {
    it('should update group successfully', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: null
      });

      // Mock history save call
      mockSupabaseChain.single.mockResolvedValueOnce({
        data: null,
        error: null
      });

      const eventSpy = jest.fn();
      service.on('configChanged', eventSpy);

      await service.updateDetectionGroup(mockGroup);

      expect(supabaseAdmin.from).toHaveBeenCalledWith('detection_groups');
      expect(mockSupabaseChain.upsert).toHaveBeenCalledWith(mockGroup, { onConflict: 'id' });
      expect(eventSpy).toHaveBeenCalledWith({
        type: 'group_updated',
        data: mockGroup
      });
    });

    it('should handle update errors', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Update failed')
      });

      await expect(service.updateDetectionGroup(mockGroup))
        .rejects.toThrow('Update failed');
    });
  });

  describe('createDetectionGroup', () => {
    const newGroupData = {
      name: 'new-group',
      display_name: 'ìƒˆ ê·¸ë£¹',
      characters: ['ìƒˆ', 'ê·¸', 'ë£¹'],
      color: 0x00ff00,
      emoji: 'ðŸ†•',
      enabled: true,
      threshold: 3
    };

    it('should create group successfully', async () => {
      const createdGroup = { ...newGroupData, id: 'new-id' };
      
      mockSupabaseChain.single.mockResolvedValue({
        data: createdGroup,
        error: null
      });

      // Mock history save
      mockSupabaseChain.single.mockResolvedValueOnce({
        data: null,
        error: null
      });

      const eventSpy = jest.fn();
      service.on('configChanged', eventSpy);

      const result = await service.createDetectionGroup(newGroupData);

      expect(result).toEqual(createdGroup);
      expect(mockSupabaseChain.insert).toHaveBeenCalledWith(newGroupData);
      expect(eventSpy).toHaveBeenCalledWith({
        type: 'group_created',
        data: createdGroup
      });
    });

    it('should handle creation errors', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Creation failed')
      });

      await expect(service.createDetectionGroup(newGroupData))
        .rejects.toThrow('Creation failed');
    });
  });

  describe('deleteDetectionGroup', () => {
    it('should delete group successfully', async () => {
      // Mock getting existing group
      mockSupabaseChain.single
        .mockResolvedValueOnce({
          data: mockGroup,
          error: null
        })
        .mockResolvedValueOnce({
          data: null,
          error: null
        });

      // Mock history save
      mockSupabaseChain.single.mockResolvedValueOnce({
        data: null,
        error: null
      });

      const eventSpy = jest.fn();
      service.on('configChanged', eventSpy);

      await service.deleteDetectionGroup('test-id');

      expect(mockSupabaseChain.delete).toHaveBeenCalled();
      expect(mockSupabaseChain.eq).toHaveBeenCalledWith('id', 'test-id');
      expect(eventSpy).toHaveBeenCalledWith({
        type: 'group_deleted',
        data: mockGroup
      });
    });

    it('should handle deletion errors', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Deletion failed')
      });

      await expect(service.deleteDetectionGroup('test-id'))
        .rejects.toThrow('Deletion failed');
    });
  });

  describe('getDetectionGroups', () => {
    it('should return groups from loaded configuration', async () => {
      mockSupabaseChain.single
        .mockResolvedValueOnce({ data: [mockGroup], error: null })
        .mockResolvedValueOnce({ data: mockSettings, error: null });

      const groups = await service.getDetectionGroups();

      expect(groups).toEqual([mockGroup]);
    });
  });

  describe('updateSystemSetting', () => {
    it('should update system setting successfully', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: null
      });

      const eventSpy = jest.fn();
      service.on('configChanged', eventSpy);

      await service.updateSystemSetting('countThreshold', 10);

      expect(mockSupabaseChain.upsert).toHaveBeenCalledWith({
        key_name: 'countThreshold',
        value_data: 10
      }, { onConflict: 'key_name' });

      expect(eventSpy).toHaveBeenCalledWith({
        type: 'setting_updated',
        data: { key: 'countThreshold', value: 10 }
      });
    });

    it('should handle setting update errors', async () => {
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Setting update failed')
      });

      await expect(service.updateSystemSetting('countThreshold', 10))
        .rejects.toThrow('Setting update failed');
    });
  });

  describe('event handling', () => {
    it('should support registering config change listeners', () => {
      const callback = jest.fn();
      service.onConfigChange(callback);

      service.emit('configChanged', { type: 'test', data: {} });

      expect(callback).toHaveBeenCalledWith({ type: 'test', data: {} });
    });
  });

  describe('cache management', () => {
    it('should invalidate cache on configuration changes', async () => {
      // Load initial config
      mockSupabaseChain.single
        .mockResolvedValueOnce({ data: [mockGroup], error: null })
        .mockResolvedValueOnce({ data: mockSettings, error: null });

      await service.loadConfiguration();

      // Update group (should invalidate cache)
      mockSupabaseChain.single.mockResolvedValue({ data: null, error: null });
      await service.updateDetectionGroup(mockGroup);

      // Next load should hit database again
      mockSupabaseChain.single
        .mockResolvedValueOnce({ data: [mockGroup], error: null })
        .mockResolvedValueOnce({ data: mockSettings, error: null });

      await service.loadConfiguration();

      expect(supabaseAdmin.from).toHaveBeenCalledTimes(5); // initial(2) + update(1) + reload(2)
    });
  });

  describe('default configuration', () => {
    it('should provide valid default configuration', async () => {
      // Force database error to trigger default config
      mockSupabaseChain.single.mockResolvedValue({
        data: null,
        error: new Error('Database unavailable')
      });

      const config = await service.loadConfiguration();

      expect(config.groups).toHaveLength(3);
      expect(config.groups[0]).toMatchObject({
        name: 'burger',
        display_name: 'ë²„ê±°',
        characters: ['ì –', 'ë²„', 'ê±°'],
        emoji: 'ðŸ”',
        enabled: true
      });
      expect(config.globalSettings).toMatchObject({
        countThreshold: 5,
        alertCooldown: 300000,
        countResetInterval: 60000
      });
    });
  });

  describe('cleanup', () => {
    it('should remove all event listeners', () => {
      const callback = jest.fn();
      service.onConfigChange(callback);

      service.cleanup();

      service.emit('configChanged', { type: 'test' });
      expect(callback).not.toHaveBeenCalled();
    });
  });
});